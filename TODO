===========================================================================
  DELEGATES, optimizing the QTreeView
===========================================================================
- see 'Delegate Classes' in assistant, then create delegates for the module properties, rethink the 'delegate' role of the
  QGraphicsItems which 'act' as delegates for my GraphicsView...
- if a property changes(a child), the parent (module) should get updated in the GraphicsScene
   SEE: void GraphicsScene::dataChanged(const QModelIndex&, const QModelIndex&)  FIXME: not implemented yet for PROPERTY 
- properties:
 - properties need an interface to be accessed via the model
 - property may be registered only once, fail with exit(1)!
 - properties should use type::int instead of "QString" for faster processing, along with a enum, which is replaced by a MAKRO
- if setData did not work, because the validator discarded the value for any reason, the QStatusBar should be used to display why

- concept: see assistant, the QTreeView there is basically what i want to clone
  - QTreeView editor for pos should split QPoint up into x and y component as it is done in assistant. is that compilicated?

- fix this:
  MainWidget.cpp:
    //void QTreeView::setFirstColumnSpanned ( int row, const QModelIndex & parent, bool span )
    treeView->setFirstColumnSpanned(0, QModelIndex(), 1);
 -> but i want that be retrieved by data(..) but span is not used yet!









20:27 < qknight> i wonder how to set a QAbstractItemDelegate* for a single QModelIndex in a QTreeView
20:28 <+zbenjamin> !f delegate
20:28 < qtassistant> zbenjamin: [delegates] http://doc.trolltech.com/latest/model-view-introduction.html#delegates
20:28 <+zbenjamin> !rtfm setDelegate
20:28 < qtassistant> zbenjamin: Qt 4.6: QFileDialog Class Reference - QFileDialog::setItemDelegate - http://doc.qt.nokia.com/qfiledialog.html#setItemDelegate
20:28 < special> you can't.
20:28 <+zbenjamin> !rtfm QAbstractItemView::setDelegate
20:28 < special> you can set delegates for everything, for rows, or for columns, but not for individual indexes
20:28 < qtassistant> zbenjamin: Qt 4.6: QAbstractItemView Class Reference - QAbstractItemView::setItemDelegate - 
                     http://doc.qt.nokia.com/qabstractitemview.html#setItemDelegate
20:29 < special> and row/column are by integer, not by QModelIndex, so in a heirarchical model, they apply to *every* row 2
20:29 < special> seriously :|
20:29 <+zbenjamin> you can
20:29 <+zbenjamin> reimplement QAbstractItemDelegate * QAbstractItemView::itemDelegate ( const QModelIndex & index ) const
20:29 <+zbenjamin> argh its not virtual
20:29 <+zbenjamin> ok you cant
20:29 < special> I was about to be excited, that would be a perfect solution
20:30 <+zbenjamin> yeah :)
20:30 < special> damn you, binary compatibility.
20:30 <+zbenjamin> you could patch your own qt version if you ship it with your project :)
20:31 < special> except that you have to deal with the LGPL requirements
20:31 < qknight> so i could assign 'one' delegate for _all_ items. then within the context of that delegate i can find out about the type of the object and based on that i 
                 can change the backend used for that delegate? is that right?
20:31 < special> qknight: Yes. I've done that before.
20:32 < qknight> special, zbenjamin: thanks very much
20:32 < qknight> i think that is a good solution
20:32 < qknight> isn't qt doing that? using one delegate for all editing things (in the default setup)
20:33 <+zbenjamin> i was about to say the same
20:33 < qknight> hehe! thanks a lot!
20:33 <+zbenjamin> reimplement your own delegate and make the delegate change for every modelindex
20:34 <+zbenjamin> s/change/behave different

*yepee*
[1] http://qt.nokia.com/products/appdev/add-on-products/catalog/4/Widgets/qtpropertybrowser/

Q: how does [1] work?
A: all examples seem to have their own model implementation for their properties, which is in short: "bad".
   one registers a QtGroupPropertyManager with various childs as:
    QtProperty *item0 = groupManager->addProperty("QObject");
   and these managers do have their own guis

   QtPointPropertyManager::setValue works like this:
    0. the data structure: typedef QMap<const QtProperty *, Data> PropertyValueMap;
    1. a property is probably unique as find is used on a ValueMap and the item found first is used and changed
    2. then two signals are fired: propertyChanged and valueChanged
   internally two m_intPropertyManager- are used

Q: why is this bad?
A: - this managers can't be used with my model (as they have their own data structure)
   - they use their own widgets, no QTreeView stuff

Q: which delegates does the 'srmg' require?
A: basically: 
   - float
   - int 
   - QPoint
   - QPointF
   - QStringDropdownList for GetNoiseQuality
   - QList<ControlPoint>

thoughts about the makro or function call to insert a new property:
  insertProperty(codeName, guiName, description, type, minValue, maxValue);

-> editors should be generated automatically based on the type given:
  - QTreeView will use delegates
  - GraphicsScene will provide it's own editor (a graphical modular approach)
  - QGraphicsItem's additional editor/view: doubleclicking will open a new QWidget with an appropriate view/editor:
    - libnoise-view                   mainly viewer, but also editor as it alters the module source position using transform
    - Modifier::Terrace controllPoint editor
    - Modifier::Curve   controllPoint editor
    - Spring::mapgen                  editor

Q: can i copy the delegates at least partially to use them with a QTreeView cell?
A:

Q: how to implement a delegate for a QTreeView at all?
A: current guess: one delegate is assigned to all cels, on certain cells the delegate changes it's representation.. somehow

modules="""                               properties
Utils NoiseMapBuilderPlane      1 0 0     ?
Utils RendererImage             1 0 0     ?
Utils Image                     1 0 0     ?

Generator Billow                0 0 1     double frequency, double lacunarity,  GetNoiseQuality (FAST/STD/BEST), int octavecount, double persistence (), int seed, 
Generator Checkerboard          0 0 1     -
Generator Const                 0 0 1     double constvalue
Generator Cylinders             0 0 1     double frequency
Generator Perlin                0 0 1     double frequency, double lacunarity,  GetNoiseQuality (FAST/STD/BEST), int octavecount, double persistence (), int seed, 
Generator RidgedMulti           0 0 1     double frequency, double lacunarity,  GetNoiseQuality (FAST/STD/BEST), int octavecount, int seed, 
Generator Spheres               0 0 1     double frequency, 
Generator Voronoi               0 0 1     bool distance, double displacement, double frequency, int seed, 

Combiner Add                    2 0 1     -
Combiner Max                    2 0 1     -
Combiner Min                    2 0 1     -
Combiner Multiply               2 0 1     -
Combiner Power                  2 0 1     -

Modifier Abs                    1 0 1     -
Modifier Clamp                  1 0 1     -
Modifier Curve                  1 0 1     several: AddControlPoint (double inputValue, double outputValue) / void   ClearAllControlPoints ()
Modifier Exponent               1 0 1     double 0.0 to 1.0; setExponent, getExponent
Modifier Invert                 1 0 1     -
Modifier ScaleBias              1 0 1     several: double GetBias/SetBias, GetScale, SetScale
Modifier Terrace                1 0 1     bool  InvertTerraces; addControlPoint(double), getControlPoint(..)

Selector Blend                  2 1 1     -
Selector Select                 2 1 1     double edgefalloff, double lowerbound, double upperbound, 

Transformer Displace            1 3 1     -
Transformer RotatePoint         1 0 1     double xangle, double yangle, double zangle
Transformer ScalePoint          1 0 1     double scale, double xscale, double yscale, double zscale
Transformer TranslatePoint      1 0 1     double translation, double xtranslation, double ytranslation, double ztranslation,
Transformer Turbulence          1 0 1     double frequency, double power, int RoughnessCount, int seed, 

Spring Mapgenerator             1 0 0     qpoint position, mapsize x,y (spring map sizetype)

second backend object factory to build the libnoise chain:
 - registers required properties at the Graphical Representation
 - is able to collect properties from the Graphical Representation and uses them to build the libnoise-chain
 - should not mix GraphicsScene coordinates with libnoise-properties as "Position" for instance, we need a 
   gui string and an internal string, so that both 'could' be named/called "Position" but one uses gui_position to store it while the
   other uses libnoise_position

Q: implementation of PropertyComponent, where int a, int b are two components of QPoint, is that complicated to write?
A: a DataItemType::PROPERTY needs to insert two childs both with an int delegate, that can be done in two ways:
   a) when inserting a property with setProperty("identifier", type);, the insert function uses type and adds two childs
   b) such an item knows that and adds two childs itself somehow?!




frontend modules are used to configure the backend module chain (libnoise). 

class LibNoiseRenderer {
  // see Utils::rendererImage, this is basically what this is about
  // see also libnoise-view's backend system with QThread(s)
}

/*! checks for syntax/semantics of the network and then creates connects all modules 
**  in the graph usable to render an image using LibNoiseRenderer */
class LibNoiseConstructor {
  libNoiseNetwork* constructNetwork(QModelIndex output module);
};



















REFACTORING:
- check the specification for QAbstractItemModel: 
 - what must be implemented, is reset and layout changes mandatory?
 - does a Model have to know that a view is attached?

===========================================================================
   why QGraphicsItem(s) do need direct access to each other sometimes
===========================================================================
   the x,y position of a module is stored in the module property (backend) and is important for the QGraphicsScene/QGraphicsView basically.
   when talking about Qt MVC the Model translates backend items into frontend items. one backend item may have several frontend items.

   however, when moving a module using a drag'n'drop operation in the QGraphicsView the connections are redrawn immediately. this helps
   to create a good looking arrangement of items as the drawing happens as fast as possible - realtime. it is important to note that the model
   is not used while moving the item and therefore the graphical representation (frontend) and the acctual module (backend) are out of
   sync. this changes when the drag'n'drop operation is finished using the 'QGraphicsItem::ItemPositionHasChanged'-signal which will 
   write the new x,y coordinate to the backend immediately.
   
   altough it seems wise to do so, at least regarding the performance increase, it can result in pitfalls as it partially breaks the
   MVC pattern, which basically says: a graphical representation (a frontend item as a module or connection) may not read data from 
   another source than the model. since updating the connection depends on the position change information of a module (both frontend items)
   we break that rule by using another frontend item (the module) to be accessed by a connection and vice versa.

   the problem now is: how to solve the frontend dependancies without adding too much code and making the process of further code changes
   more error phrone.

   there are a few different ways:
   - slow: always use scene->items().contains(myItem) before acutally using that 'myItem'. this check would only check if that particular
     frontend item exists, before using it.
     FAIL: this is slow as hell

   - all frontend items could implement an 'reference counter' using smart pointers. the object exists until the last reference is removed
     FAIL: this does not work as the dependancy builds a loop between two objects

   - extend all QGraphicsItems by inheriting also QObject, then use signals+slots
     FAIL: so every QGraphicsItem (namely Port/Connection/Module) needs to inherit from QObject, setProperty currently used will
           have to be renamed as well

   - frontend items do register or unregister their references manually:
     this can be very complex and error phrone [CURRENTLY IMPLEMENTED]

   - use a messanger class which is used to forward messages between frontend classes: 
    - objects can register and unregister at any time
    - this messanger class could be implemented using an object counter (smart pointer(s)?)
    - the last unregister will remove the messanger 

   problem viewed from the (frontend) module side:
     onModuleMove: foreach(module-port(s)-connection(s), Connection* c) c->updatePosition();

    I if a connection is removed, it has to inform the port to not request update(); anymore
   II if a module (therefore the ports are removed) each port has to inform the connection not to use it anymore (in case of I)

   -> therefore:
     - graphical representations must be designed in a way that they can work even when not all dependacies are meat:
       -> inserting a module: [NOT IMPLEMENTED]
          creating a module, then creating a connection but the second module isn't there yet, if the second module is created the connection
          starts the drawing. see class 'Connection' for issues
       -> deleting a module: [IMPLEMENTED]
          same when two modules exist and one connection. now the reset() clears all objects in arbitrary order: one module goes down, the 
          connection simply suspends accessing the module which is now not accessable anymore

13:17 <peer> Hi
13:19 <peer> What is still unclear for me, is how you model the idea of connections from your QAIM.
this is quite complex:
a connection is a child of a node, and a node is a child of the root so we have 3 different types. all share a abstract base class.
a connection is basically a pointer to another node. and the other node does also own a reference (which is not stored as a connection), so
the reference is invisible to the model. 
 - but when deleting either node we can see that there is either a reference or a connection. in both cases we have to do something about it.

the GraphicsView visualizes that connection and the model helps to find the connections destination QModelIndex with dst(..); this way
we can construct a Connection object knowing both parents.

if you have further question, please ask. note also that the QGraphicsItem(s) do break MVC as they tend to query data not using the model but:
 - a node updates a connection if it is moved
 - a connection notifies a node that it is gone, when it is deleted (might not be true for the automate project but for the springrts rng mapper)

bootstrapping and removing of such objects tends to be quite complex and error phrone as one has to keep in mind that objects in the gui might
not exist yet when launching a new gui. example: a node is generated, then the connection: but dst(..) finds a QPersistentModelIndex which does
not yet have a QGraphicsItem associated. (this is not fixed currently - in both projects)
if i recall correctly then:
 - automate project tries to insert all nodes, then all connections. this helps to keep object dependancies in the gui consistent
 - springrts.com rng mapper does not have such handling yet

13:19 <peer> Also, I think your approach lacks a bit of flexibility.
13:19 <peer> Let me explain that later point:
13:21 <peer> For one: as far as I see, there is no way to use different types of GrahicsItems to represent different types of nodes.
13:22 <peer> You can obviously not use the same approach as QAIV uses (delegates), as there is only one delegate that does the drawing for a lot of items. Since your 
                items are interactive objects on your graphics view, that is not going to work.
13:23 <peer> But: why not use the same approach as there is for the *editors* for item views: use a factory approach. That lets you specify what type of GraphicsItem 
                should be used to represent what type of node in your model.
yes can actually do that without much trouble:
in the gui part, just create a base class and then according to a type information create the object of your choice. in my cases i didn't need to yet.
but if you want i can give you further hints, where to modify which code. in general this is:
ItemView.cpp::rowsInserted(..)
 if (data(index, myTypeRole) == freakyModule)
    return create(freakyModule);
 if (data(index, myTypeRole) == normalModule)
    return create(normalModule)
this can obviously extended by a factory


13:24 <peer> Furthermore, I find it a bit limiting that the layout is defined by properties the items in the model.
13:25 <peer> Sure, that is one way to do it, but why not make that more flexible? Why not use a separate layout manager class that provides this layout in some, 
                undefined, way? The default one may just use coordinates stored in your items, but it would not be very flexible to assume items always have them...
the layout can be adapted by a central instance. you can do so using two different approaches:
 1. if a new node is created then place it below the cursor (this is the default when inserting with the mouse)
    but if a new item is inserted using the TreeView one has to find a good position for that item, which can be done by the backend

 2. there could be a button which will layout the items using a library as graphviz. the Model::layoutChange signal is the candidate there
    as it does not require a view to remove all items but instead only changes their position. (in contrast to modelReset())

please keep in mind that:
 - qt views actually 'want' view independant coordinates of objects, this helps to have individual view(s) of the items
 - my concept was different: i wanted a base layout for all items. 
   -> one opens a new view the same position are used. 
   -> BUT i wanted to be able to modify the item individually per view later on
   -> my code IS not consistent as load/save was never implemented and therefore i got two states of object positions:
     - the position in the backend stored/retrieved via the property/setProperty functions from QObject
     - the altered positions in the QGraphicsView, these were never written back to the model once touched

create a blog entry and discuss the O(?) problems as:
 - have a look at FAQ, move this discussion there?!
 - how many items can be inserted?
 - how fast is model 2 screen index and vice versa
 - overhead by removing/inserting of new items
 - messanger objects for frontend to frontend module function calls
  - view to view dependancies for faster drawing, discuss resutling issues













     







=================================================================================
  Model related: Adding, selecting, changing, removing of single/multiple items:
=================================================================================
- QTreeView did not show anything lately:
  see FilterProxyModel changes.
  this bug didn't show up before as DataItemType::ROOT was actually 0. but now it is not anymore!
  so i've added some code when having an invalid QModelIndex it simply retuns true...? and now it's working again...
  what special role did have a invalid QModelIndex have in a model?!
- FIXME: - have a look at Model::removeRows and Model::parent, there is some strange things going on, 
           especially with the handling of rootItem and QModelIndex()
         - the rootItem should return a valid QModelIndex() and rootItem->parent() should return QModelIndex()
- bug: 'virtual void DataPort::removeChild(unsigned int) this should not happen' does show up at some configurations. not sure why?!

- implement QSettings for QTreeView column width
    MainWidget::changeActiveDocument() -> replace by QSettings... treeView->setColumnWidth(0, 230);
- QTreeView: add tooltips
- bug: if a module makes doubleuse of a outgoing port, one can NOT connect new connections to any input port of that module!
       however: if the second output usage is removed one can connect the input ports as expected, later the second output
                can be connected again...?!
       - this fails silently, create a debug message
       - this bug is in Model::insertConnection(..) for sure
       to reproduce:
       insert perlin p1; selector s1, selector s2; connect s1.out1 to s2.in1 and s1.out1 to s2.in2, then try to connect p1 to 
              s1.in1 and s2.put1 as well, will not work. will work if no double use of s1.out1 is made!
       FIX is: first find similar connections as (s1.out1 - s2.in1) AND (s1.out1 - s2.in2), and then only process one of these
       IMPORTANT: add a qDebug() statement why it does fail










========================================================================
  Fixing QGraphicsItem(s) and the behaviour of the QGraphicsView:
========================================================================
- selection of connections does not work well?
- fixme: when selecting an module, and while hoovering&moving it: delete it using 'del'-key. 
         the next item will instantly port to 'x,y=0,0', when moving it, using a drag'n'drop operation
         issue might be: when the item is removed, there is still some pos() thing going on and when the next item is moved it is
                         moved to the previous item's position, which is QVariant().toPoint(), so 0,0
- cubic_to may be hardware accelerated if i enable opengl in src/CMakeLists.txt as well as for the QGraphicsScene/*View
- Connection drawing could be nicer
 - drawing of the connection path: if x1 and x2 from the different coordinates are the same and y1 and y2 differ much then the
   path looks somehow broken. it should have a nice arc or bow like shape
- creating a connection currently is done clicking a port with a drag'n'drop operation:
  this should be changed: clicking once will change the mousecursor to a port draw operation cursor, next the line will always follow from
  the source port to the mouse cursor (basically what it does currently) until the next click which then checks if a valid port was clicked.
  this would enable connecting two ports which are not in the same view as the scene might be bigger than the current view port
- QStatusBar should receive messages, especially when loops are formed or connection attemps are done wrongly
- fix all FIXME lines in all frontend classes
- creat 'visual indication' like a red ball behind the port to represent various PortType(s)
- also add a little 'x' button on the top right side of the module (similar to widgets)
- make items selectable with:
 - boundingbox selection
  - set bounding box selection using a modifier key, say ctrl
- clicking an item in the right list should focus the view of the graphicsscene over the respective item
- FIXME: insert modules at 'out of sight' will create strange view relocations...
         this happens when items (not connections) are inserted via Document.cpp
- QGraphicsItem(s) should be a QWidget (for module preview) so that one can scroll the view port of a noisegen right from there.
  + this would be cool as it would make editing much faster and more interactive
  + also resizing could be implemented, so one could increase the area which is viewed
- adding a connection (when no connection was added before whill relocate the view quite far away?!)
- using Document.cpp::Document()'s insertConnection will add scrollbars to the QGraphicsView... ;P
 - so i have to fix my QGraphicsView code once again
 - it's funny that clicking a item in the right side will now focus over the respecitive QGraphicsItem (didn't work before)
 - scrollbars should always be there
- softscroll to item instead of immediate focus
- implement singleselection:
  > if an item in the graphicsview is selected, the QTreeView should only show the respective properties of that item
  + if more items are selected, diplay all selected items
  + if no item is selected anymore, show all items in the QTreeView
- fix regression: QTreeView modules can't be clicked to focus the QGraphicsView over it anymore

GraphicsView:
 - zoomin/zoomout (mwheel or +/-) and zoomfit (gui button)
 - move selected items should 'move the view' if moved towards the border of the view (or beyond)
 - connection snapping, as indication when creating a new connection
 - modput needs some redesigning, see modules which use more than one modput: transformer::displace
 - scrollbars in GraphicsView are currently disabled by the resizeEvent(..) implementation, maybe
   they should indicated the document width()/height() and making it work might be by using
   POSSIBLE FIX: centerOn(..) or scroll(..)
 - when selecting a GraphicsItem using a click on the respecitive QTreeView item, the item should be animated for some time

















========================================================================
  General concepts to consider:
========================================================================
- documentation: include a qwebkit browser with some html documentation about the modules
- concept: each item MUST be able to host one/many QWidget(s) as for instance: an editor or a libnoise-view
- Design choice:
  using min/max or select with libnoise can have interesting outcomes. the colorizer should know of which root the pixel was from to
  enable context sensitive coloring. this would be funny as one could create different effects on the same height. 
  imagine a landscape with flat hills. on top of the hills are various holes but these holes are textured differently.

- libNoiseAbstraction (frontend) need to be created
   WARNING: a property might have serious dependancies as: int 1,2,4,8 and if one set's 5 the libnoise library will create
            an exception which we most likely don't handle which will bring down the whole program.
            therefore: every property has to provide an input checker, which skips invalid input with some feedback.
- libNoise (backend) and

- integrate libNoise-view (first refactore it)

- integrate spring map exporter (smf or s3m)

- integrate height-colorizer and height-texturizer
  the height-colorizer is easy to implement and gives a basic look&feel for the heightmap
  the height-texturizer is basically the same but instead of applying a color it inserts
  textures, the textures do have a fixed orientation. later this might be adapted to reflect
  the gradient of the landscape and other parameters as wind-pressure artefacts in sand dunes...

- integrate xml save/load functionality (add an object serializer to all nodes in the graph)
  - load+save viewport-position in document
- fix copyright, linking to the gpl? library .... is that possible?

- integrate 3d viewer (adapted/copied from qtlobby)

- include libnoise into this CMakeLists.txt (build it as well and use that)

- official release of 'the source as package'

- new moduels which might be nice:
 - rain simulation (also known as erosion)
 - blur filter (imagemagick filters in general, if they are arch-independant say 32vs64bit should output
                the same image, the same goes for intel vs spark)
