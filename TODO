REFACTORING:

- check the specification for QAbstractItemModel: 
 - what must be implemented, is reset and layout changes mandatory?
 - does a Model have to know that a view is attached?

- extend GraphicsItemModelExtension by GraphicsScene::model2GraphicsItem(..)
- the GraphicsScene needs this extension as well because clicked items should be filtered (shown only) in the QTreeView

- refactore both model2GraphicsItem and graphicsItem2Model

- QGraphicsItems should be more or less designed to be a delegate

and both functions:
 - QGraphicsItem* GraphicsScene::model2GraphicsItem ( QPersistentModelIndex index ) {
 - QPersistentModelIndex GraphicsScene::graphicsItem2Model ( QGraphicsItem* graphicsItem ) {
will have to find a new home since they have to be accessable in both:
 - the abstractGraphicsItem class (and)
 - the GraphicsScene class

===========================================================================
   why QGraphicsItem(s) do need direct access to each other sometimes
===========================================================================
   the x,y position of a module is stored in the module property (backend) and is important for the QGraphicsScene/QGraphicsView basically.
   when talking about Qt MVC the Model translates backend items into frontend items. one backend item may have several frontend items.

   however, when moving a module using a drag'n'drop operation in the QGraphicsView the connections are redrawn immediately. this helps
   to create a good looking arrangement of items as the drawing happens as fast as possible - realtime. it is important to note that the model
   is not used while moving the item and therefore the graphical representation (frontend) and the acctual module (backend) are out of
   sync. this changes when the drag'n'drop operation is finished using the 'QGraphicsItem::ItemPositionHasChanged'-signal which will 
   write the new x,y coordinate to the backend immediately.
   
   altough it seems wise to do so, at least regarding the performance increase, it can result in pitfalls as it partially breaks the
   MVC pattern, which basically says: a graphical representation (a frontend item as a module or connection) may not read data from 
   another source than the model. since updating the connection depends on the position change information of a module (both frontend items)
   we break that rule by using another frontend item (the module) to be accessed by a connection and vice versa.

   the problem now is: how to solve the frontend dependancies without adding too much code and making the process of further code changes
   more error phrone.

   there are a few different ways:
   - slow: always use scene->items().contains(myItem) before acutally using that 'myItem'. this check would only check if that particular
     frontend item exists, before using it.

   - all frontend items could implement an 'reference counter' using smart pointers. the object exists until the last reference is removed

   - frontend items do register or unregister their references manually:
     this can be very complex and error phrone [CURRENTLY IMPLEMENTED]

   - extend all QGraphicsItems by inheriting also QObject, then use signals+slots

   problem viewed from the (frontend) module side:
     onModuleMove: foreach(module-port(s)-connection(s), Connection* c) c->updatePosition();

    I if a connection is removed, it has to inform the port to not request update(); anymore
   II if a module (therefore the ports are removed) each port has to inform the connection not to use it anymore (in case of I)

   -> therefore:
     - graphical representations must be designed in a way that they can work even when not all dependacies are meat:
       -> creating a module, then creating a connection but the second module isn't there yet, if the second module is created the connection
          starts the drawing. 
       -> same when two modules exist and one connection. now the reset() clears all objects in arbitrary order: one module goes down, the 
          connection simply suspends accessing the module which is now not accessable anymore

13:17 <peer> Hi
13:19 <peer> What is still unclear for me, is how you model the idea of connections from your QAIM.
this is quite complex:
a connection is a child of a node, and a node is a child of the root so we have 3 different types. all share a abstract base class.
a connection is basically a pointer to another node. and the other node does also own a reference (which is not stored as a connection), so
the reference is invisible to the model. 
 - but when deleting either node we can see that there is either a reference or a connection. in both cases we have to do something about it.

the GraphicsView visualizes that connection and the model helps to find the connections destination QModelIndex with dst(..); this way
we can construct a Connection object knowing both parents.

if you have further question, please ask. note also that the QGraphicsItem(s) do break MVC as they tend to query data not using the model but:
 - a node updates a connection if it is moved
 - a connection notifies a node that it is gone, when it is deleted (might not be true for the automate project but for the springrts rng mapper)

bootstrapping and removing of such objects tends to be quite complex and error phrone as one has to keep in mind that objects in the gui might
not exist yet when launching a new gui. example: a node is generated, then the connection: but dst(..) finds a QPersistentModelIndex which does
not yet have a QGraphicsItem associated. (this is not fixed currently - in both projects)
if i recall correctly then:
 - automate project tries to insert all nodes, then all connections. this helps to keep object dependancies in the gui consistent
 - springrts.com rng mapper does not have such handling yet

13:19 <peer> Also, I think your approach lacks a bit of flexibility.
13:19 <peer> Let me explain that later point:
13:21 <peer> For one: as far as I see, there is no way to use different types of GrahicsItems to represent different types of nodes.
13:22 <peer> You can obviously not use the same approach as QAIV uses (delegates), as there is only one delegate that does the drawing for a lot of items. Since your 
                items are interactive objects on your graphics view, that is not going to work.
13:23 <peer> But: why not use the same approach as there is for the *editors* for item views: use a factory approach. That lets you specify what type of GraphicsItem 
                should be used to represent what type of node in your model.
yes can actually do that without much trouble:
in the gui part, just create a base class and then according to a type information create the object of your choice. in my cases i didn't need to yet.
but if you want i can give you further hints, where to modify which code. in general this is:
ItemView.cpp::rowsInserted(..)
 if (data(index, myTypeRole) == freakyModule)
    return create(freakyModule);
 if (data(index, myTypeRole) == normalModule)
    return create(normalModule)
this can obviously extended by a factory


13:24 <peer> Furthermore, I find it a bit limiting that the layout is defined by properties the items in the model.
13:25 <peer> Sure, that is one way to do it, but why not make that more flexible? Why not use a separate layout manager class that provides this layout in some, 
                undefined, way? The default one may just use coordinates stored in your items, but it would not be very flexible to assume items always have them...
the layout can be adapted by a central instance. you can do so using two different approaches:
 1. if a new node is created then place it below the cursor (this is the default when inserting with the mouse)
    but if a new item is inserted using the TreeView one has to find a good position for that item, which can be done by the backend

 2. there could be a button which will layout the items using a library as graphviz. the Model::layoutChange signal is the candidate there
    as it does not require a view to remove all items but instead only changes their position. (in contrast to modelReset())

please keep in mind that:
 - qt views actually 'want' view independant coordinates of objects, this helps to have individual view(s) of the items
 - my concept was different: i wanted a base layout for all items. 
   -> one opens a new view the same position are used. 
   -> BUT i wanted to be able to modify the item individually per view later on
   -> my code IS not consistent as load/save was never implemented and therefore i got two states of object positions:
     - the position in the backend stored/retrieved via the property/setProperty functions from QObject
     - the altered positions in the QGraphicsView, these were never written back to the model once touched

create a blog entry and discuss the O(?) problems as:
 - have a look at FAQ, move this discussion there?!
 - how many items can be inserted?
 - how fast is model 2 screen index and vice versa
 - overhead by removing/inserting of new items













- BUG: program crashes if a new connection is drawn from a Port to nowhere
     
- selection of connections does not work well?

- cubic_to may be hardware accelerated if i enable opengl in src/CMakeLists.txt as well as for the QGraphicsScene/*View


- fixme: when selecting an module, and while hoovering&moving it: delete it using 'del'-key. 
         the next item will instantly port to 'x,y=0,0', when moving it, using a drag'n'drop operation
         issue might be: when the item is removed, there is still some pos() thing going on and when the next item is moved it is
                         moved to the previous item's position, which is QVariant().toPoint(), so 0,0

- bug: if a module makes doubleuse of a outgoing port, one can NOT connect new connections to any input port of that module!
       however: if the second output usage is removed one can connect the input ports as expected, later the second output
                can be connected again...?!
       - this fails silently, create a debug message
       - this bug is in Model::insertConnection(..) for sure
       to reproduce:
       insert perlin p1; selector s1, selector s2; connect s1.out1 to s2.in1 and s1.out1 to s2.in2, then try to connect p1 to 
              s1.in1 and s2.put1 as well, will not work. will work if no double use of s1.out1 is made!
       FIX is: first find similar connections as (s1.out1 - s2.in1) AND (s1.out1 - s2.in2), and then only process one of these
       IMPORTANT: add a qDebug() statement why it does fail

- bug: virtual void DataPort::removeChild(unsigned int) this should not happen

- FIXME: in functions as insertModule: add a check to the parameters (done there, but i need to check other similar functions)
         this could avoid a lot of segfaults when inserting new concepts into the code


=================================================================================
  Model related: Adding, selecting, changing, removing of single/multiple items:
=================================================================================
- fix: ~Model and removeRows(..) for rootItem
- QTreeView did not show anything lately:
  see FilterProxyModel changes.
  this bug didn't show up before as DataItemType::ROOT was actually 0. but now it is not anymore!
  so i've added some code when having an invalid QModelIndex it simply retuns true...? and now it's working again...
  what special role did have a invalid QModelIndex have in a model?!
- FIXME: - have a look at Model::removeRows and Model::parent, there is some strange things going on, 
           especially with the halding of rootItem and QModelIndex()
         - the rootItem should return a valid QModelIndex() and rootItem->parent() should return QModelIndex()
- if a property changes(a child), the parent (module) should get updated in the GraphicsScene
- QTreeView is not expanded when loading modules via Document.cpp, is that a problem for later load/save?
- concept: see assistant, the QTreeView there is basically what i want to clone
  - QTreeView editor for pos should split QPoint up into x and y component as it is done in assistant. is that compilicated?
  - see 'Delegate Classes' in assistant, then create delegates for the module properties, rethink the 'delegate' role of the
    QGraphicsItems which 'act' as delegates for my GraphicsView...

- properties:
 - properties need an interface to be accessed via the model
 - property may be registered only once, fail with exit(1)!
 - properties should use type::int instead of "QString" for faster processing, along with a enum, which is replaced by a MAKRO

- implement QSettings for QTreeView column width
    MainWidget::changeActiveDocument() -> replace by QSettings... treeView->setColumnWidth(0, 230);
- QTreeView: add tooltips










========================================================================
  Fixing QGraphicsItem(s) and the behaviour of the QGraphicsView:
========================================================================
- Connection drawing could be nicer
 - drawing of the connection path: if x1 and x2 from the different coordinates are the same and y1 and y2 differ much then the
   path looks somehow broken. it should have a nice arc or bow like shape
- CTRL+A should select all QGraphicsItems
- creating a connection currently is done clicking a port with a drag'n'drop operation:
  this should be changed: clicking once will change the mousecursor to a port draw operation cursor, next the line will always follow from
  the source port to the mouse cursor (basically what it does currently) until the next click which then checks if a valid port was clicked.
  this would enable connecting two ports which are not in the same view as the scene might be bigger than the current view port
- QStatusBar should receive messages, especially when loops are formed or connection attemps are done wrongly
- fix all FIXME lines in all frontend classes
- creat 'visual indication' like a red ball behind the port to represent various PortType(s)
- also add a little 'x' button on the top right side of the module (similar to widgets)
- make items selectable with:
 - boundingbox selection
  - set bounding box selection using a modifier key, say ctrl
- clicking an item in the right list should focus the view of the graphicsscene over the respective item
- FIXME: insert modules at 'out of sight' will create strange view relocations...
         this happens when items (not connections) are inserted via Document.cpp
- QGraphicsItem(s) should be a QWidget (for module preview) so that one can scroll the view port of a noisegen right from there.
  + this would be cool as it would make editing much faster and more interactive
  + also resizing could be implemented, so one could increase the area which is viewed
- adding a connection (when no connection was added before whill relocate the view quite far away?!)
- using Document.cpp::Document()'s insertConnection will add scrollbars to the QGraphicsView... ;P
 - so i have to fix my QGraphicsView code once again
 - it's funny that clicking a item in the right side will now focus over the respecitive QGraphicsItem (didn't work before)
 - scrollbars should always be there
- softscroll to item instead of immediate focus
- implement singleselection:
  > if an item in the graphicsview is selected, the QTreeView should only show the respective properties of that item
  + if more items are selected, diplay all selected items
  + if no item is selected anymore, show all items in the QTreeView
- think about how to integrate custom pixmaps rendered by libnoise as preview per Module : QGraphicsItem
- fix regression: QTreeView modules can't be clicked to focus the QGraphicsView over it anymore
- fix this:
MainWidget.cpp:
    //void QTreeView::setFirstColumnSpanned ( int row, const QModelIndex & parent, bool span )
    treeView->setFirstColumnSpanned(0, QModelIndex(), 1);
 -> but i want that be retrieved by data(..) but span is not used yet!

GraphicsView:
 - zoomin/zoomout (mwheel or +/-) and zoomfit (gui button)
 - move selected items should 'move the view' if moved towards the border of the view (or beyond)
- connection snapping, as indication when creating a new connection
- modput needs some redesigning, see modules which use more than one modput: transformer::displace
- scrollbars in GraphicsView are currently disabled by the resizeEvent(..) implementation, maybe
  they should indicated the document width()/height() and making it work might be by using
  POSSIBLE FIX: centerOn(..) or scroll(..)
- when selecting a GraphicsItem using a click on the respecitive QTreeView item, the item should make an animation
- add icons to the QMenu for categories as well as for single modules

















========================================================================
  General concepts to consider:
========================================================================
- documentation: include a qwebkit browser with some html documentation about the modules
- concept: each item MUST be able to host one/many QWidget(s) as for instance: an editor or a libnoise-view
- Design choice:
  using min/max or select with libnoise can have interesting outcomes. the colorizer should know of which root the pixel was from to
  enable context sensitive coloring. this would be funny as one could create different effects on the same height. 
  imagine a landscape with flat hills. on top of the hills are various holes but these holes are textured differently.

- libNoiseAbstraction (frontend) need to be created
   WARNING: a property might have serious dependancies as: int 1,2,4,8 and if one set's 5 the libnoise library will create
            an exception which we most likely don't handle which will bring down the whole program.
            therefore: every property has to provide an input checker, which skips invalid input with some feedback.
- libNoise (backend) and

- integrate libNoise-view (first refactore it)

- integrate spring map exporter (smf or s3m)

- integrate height-colorizer and height-texturizer
  the height-colorizer is easy to implement and gives a basic look&feel for the heightmap
  the height-texturizer is basically the same but instead of applying a color it inserts
  textures, the textures do have a fixed orientation. later this might be adapted to reflect
  the gradient of the landscape and other parameters as wind-pressure artefacts in sand dunes...

- integrate xml save/load functionality (add an object serializer to all nodes in the graph)
  - load+save viewport-position in document
- fix copyright, linking to the gpl? library .... is that possible?

- integrate 3d viewer (adapted/copied from qtlobby)

- include libnoise into this CMakeLists.txt (build it as well and use that)

- official release of 'the source as package'

- new moduels which might be nice:
 - rain simulation (also known as erosion)
 - blur filter (imagemagick filters in general, if they are arch-independant say 32vs64bit should output
                the same image, the same goes for intel vs spark)
